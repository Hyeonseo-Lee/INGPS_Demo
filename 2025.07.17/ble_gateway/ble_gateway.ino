#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>
#include <BLEClient.h>
#include <ArduinoJson.h>
#include <HardwareSerial.h>
#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <credentials.h>

// ====== ÌïÄ ÏÑ§Ï†ï ======
#define UART_RX 44
#define UART_TX 43

// ====== MQTT ÏÑ§Ï†ï ======
const char* mqttServerAddress = "9c500c1053df40c795c005da44aee8f0.s2.eu.hivemq.cloud";
const int mqttPort = 8883;

const char* mqttClientId = "ESP32_BLE_Gateway";

// MQTT ÌÜ†ÌîΩ ÏÑ§Ï†ï
const char* mqttTopicPrefix = "sensors/";
const char* mqttTopicStatus = "sensors/gateway/status";

// ====== Root CA Ïù∏Ï¶ùÏÑú (HiveMQ Cloud) ======
const char* rootCACert = \
"-----BEGIN CERTIFICATE-----\n" \
"MIIFYDCCBEigAwIBAgIQQAF3ITfU6UK47naqPGQKtzANBgkqhkiG9w0BAQsFADA/\n" \
"MSQwIgYDVQQKExtEaWdpdGFsIFNpZ25hdHVyZSBUcnVzdCBDby4xFzAVBgNVBAMT\n" \
"DkRTVCBSb290IENBIFgzMB4XDTIxMDEyMDE5MTQwM1oXDTI0MDkzMDE4MTQwM1ow\n" \
"TzELMAkGA1UEBhMCVVMxKTAnBgNVBAoTIEludGVybmV0IFNlY3VyaXR5IFJlc2Vh\n" \
"cmNoIEdyb3VwMRUwEwYDVQQDEwxJU1JHIFJvb3QgWDEwggIiMA0GCSqGSIb3DQEB\n" \
"AQUAA4ICDwAwggIKAoICAQCt6CRz9BQ385ueK1coHIe+3LffOJCMbjzmV6B493XC\n" \
"ov71am72AE8o295ohmxEk7axY/0UEmu/H9LqMZshftEzPLpI9d1537O4/xLxIZpL\n" \
"wYqGcWlKZmZsj348cL+tKSIG8+TA5oCu4kuPt5l+lAOf00eXfJlII1PoOK5PCm+D\n" \
"LtFJV4yAdLbaL9A4jXsDcCEbdfIwPPqPrt3aY6vrFk/CjhFLfs8L6P+1dy70sntK\n" \
"4EwSJQxwjQMpoOFTJOwT2e4ZvxCzSow/iaNhUd6shweU9GNx7C7ib1uYgeGJXDR5\n" \
"bHbvO5BieebbpJovJsXQEOEO3tkQjhb7t/eo98flAgeYjzYIlefiN5YNNnWe+w5y\n" \
"sR2bvAP5SQXYgd0FtCrWQemsAXaVCg/Y39W9Eh81LygXbNKYwagJZHduRze6zqxZ\n" \
"Xmidf3LWicUGQSk+WT7dJvUkyRGnWqNMQB9GoZm1pzpRboY7nn1ypxIFeFntPlF4\n" \
"FQsDj43QLwWyPntKHEtzBRL8xurgUBN8Q5N0s8p0544fAQjQMNRbcTa0B7rBMDBc\n" \
"SLeCO5imfWCKoqMpgsy6vYMEG6KDA0Gh1gXxG8K28Kh8hjtGqEgqiNx2mna/H2ql\n" \
"PRmP6zjzZN7IKw0KKP/32+IVQtQi0Cdd4Xn+GOdwiK1O5tmLOsbdJ1Fu/7xk9TND\n" \
"TwIDAQABo4IBRjCCAUIwDwYDVR0TAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAQYw\n" \
"SwYIKwYBBQUHAQEEPzA9MDsGCCsGAQUFBzAChi9odHRwOi8vYXBwcy5pZGVudHJ1\n" \
"c3QuY29tL3Jvb3RzL2RzdHJvb3RjYXgzLnA3YzAfBgNVHSMEGDAWgBTEp7Gkeyxx\n" \
"+tvhS5B1/8QVYIWJEDBUBgNVHSAETTBLMAgGBmeBDAECATA/BgsrBgEEAYLfEwEB\n" \
"ATAwMC4GCCsGAQUFBwIBFiJodHRwOi8vY3BzLnJvb3QteDEubGV0c2VuY3J5cHQu\n" \
"b3JnMDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuaWRlbnRydXN0LmNvbS9E\n" \
"U1RST09UQ0FYM0NSTC5jcmwwHQYDVR0OBBYEFHm0WeZ7tuXkAXOACIjIGlj26Ztu\n" \
"MA0GCSqGSIb3DQEBCwUAA4IBAQAKcwBslm7/DlLQrt2M51oGrS+o44+/yQoDFVDC\n" \
"5WxCu2+b9LRPwkSICHXM6webFGJueN7sJ7o5XPWioW5WlHAQU7G75K/QosMrAdSW\n" \
"9MUgNTP52GE24HGNtLi1qoJFlcDyqSMo59ahy2cI2qBDLKobkx/J3vWraV0T9VuG\n" \
"WCLKTVXkcGdtwlfFRjlBz4pYg1htmf5X6DYO8A4jqv2Il9DjXA6USbW1FzXSLr9O\n" \
"he8Y4IWS6wY7bCkjCWDcRQJMEhg76fsO3txE+FiYruq9RUWhiF1myv4Q6W+CyBFC\n" \
"Dfvp7OOGAN6dEOM4+qR9sdjoSYKEBpsr6GtPAQw4dy753ec5\n" \
"-----END CERTIFICATE-----\n";

// ====== UUID (ÏÜ°Ïã† ÏΩîÎìúÏôÄ ÎèôÏùº) ======
#define SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define CHARACTERISTIC_UUID "abcd1234-5678-90ab-cdef-1234567890ab"

// ====== ÏÑºÏÑú ÎÖ∏Îìú Íµ¨Ï°∞Ï≤¥ ======
struct SensorNode {
  String name;
  BLEClient* pClient;
  BLERemoteCharacteristic* pRemoteCharacteristic;
  BLEAdvertisedDevice* device;
  bool connected;
  bool doConnect;
  String dataBuffer;
  unsigned long lastDataTime;
  unsigned long lastConnectionAttempt;
  int openBraces;      // Ïó¥Î¶∞ Ï§ëÍ¥ÑÌò∏ Í∞úÏàò
  int closeBraces;     // Îã´Ìûå Ï§ëÍ¥ÑÌò∏ Í∞úÏàò
  bool inString;       // Î¨∏ÏûêÏó¥ ÎÇ¥Î∂Ä Ïó¨Î∂Ä
  bool escapeNext;     // Îã§Ïùå Î¨∏ÏûêÍ∞Ä Ïù¥Ïä§ÏºÄÏù¥ÌîÑ Î¨∏ÏûêÏù∏ÏßÄ
};

// ====== Í∞ùÏ≤¥ ÏÑ†Ïñ∏ ======
HardwareSerial MySerial(1);
WiFiClientSecure wifiClient;
PubSubClient mqttClient(wifiClient);
BLEScan* pBLEScan = nullptr;

// ====== ÏÑºÏÑú ÎÖ∏Îìú Î∞∞Ïó¥ ======
const int NUM_SENSORS = 2;
SensorNode sensors[NUM_SENSORS];

// ====== ÏÉÅÌÉú Î≥ÄÏàò ======
bool doScan = false;
unsigned long lastScanTime = 0;
unsigned long lastMqttReconnectAttempt = 0;
const unsigned long DATA_TIMEOUT = 5000;  // 2Ï¥à ÌõÑ Î≤ÑÌçº Ï≤òÎ¶¨
const unsigned long CONNECTION_RETRY_INTERVAL = 5000;  // 5Ï¥à
const unsigned long SCAN_INTERVAL = 10000;             // 10Ï¥à
const unsigned long MQTT_RECONNECT_INTERVAL = 5000;    // 5Ï¥à

// ====== WiFi Ïó∞Í≤∞ Ìï®Ïàò ======
void connectToWiFi() {
  MySerial.println("üì∂ WiFi Ïó∞Í≤∞ ÏãúÎèÑ...");
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    MySerial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    MySerial.println();
    MySerial.println("‚úÖ WiFi Ïó∞Í≤∞ ÏÑ±Í≥µ!");
    MySerial.print("üìç IP Ï£ºÏÜå: ");
    MySerial.println(WiFi.localIP());
  } else {
    MySerial.println();
    MySerial.println("‚ùå WiFi Ïó∞Í≤∞ Ïã§Ìå®!");
  }
}

// ====== MQTT Ïó∞Í≤∞ Ìï®Ïàò ======
bool connectToMQTT() {
  if (mqttClient.connected()) {
    return true;
  }
  
  MySerial.println("üîó MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ ÏãúÎèÑ...");
  
  // Root CA Ïù∏Ï¶ùÏÑú ÏÑ§Ï†ï (ÌîÑÎ°úÎçïÏÖòÏö© Î≥¥Ïïà Ïó∞Í≤∞)
  wifiClient.setCACert(rootCACert);
  
  MySerial.println("üîí TLS Ïù∏Ï¶ùÏÑú Í≤ÄÏ¶ù ÌôúÏÑ±ÌôîÎê®");
  
  if (mqttClient.connect(mqttClientId, mqttUsername, mqttPassword)) {
    MySerial.println("‚úÖ MQTT Î∏åÎ°úÏª§ Ïó∞Í≤∞ ÏÑ±Í≥µ!");
    
    // Í≤åÏù¥Ìä∏Ïõ®Ïù¥ ÏÉÅÌÉú Î∞úÌñâ
    mqttClient.publish(mqttTopicStatus, "online", true);
    
    return true;
  } else {
    MySerial.print("‚ùå MQTT Ïó∞Í≤∞ Ïã§Ìå®, Ïò§Î•ò ÏΩîÎìú: ");
    MySerial.println(mqttClient.state());
    return false;
  }
}

// ====== MQTT Îç∞Ïù¥ÌÑ∞ Î∞úÌñâ Ìï®Ïàò ======
void publishSensorData(const String& sensorName, const String& jsonData) {
  if (!mqttClient.connected()) {
    return;
  }
  
  String topic = mqttTopicPrefix + sensorName + "/data";
  
  if (mqttClient.publish(topic.c_str(), jsonData.c_str())) {
    MySerial.println("üì§ [" + sensorName + "] MQTT Îç∞Ïù¥ÌÑ∞ Î∞úÌñâ ÏÑ±Í≥µ");
  } else {
    MySerial.println("‚ùå [" + sensorName + "] MQTT Îç∞Ïù¥ÌÑ∞ Î∞úÌñâ Ïã§Ìå®");
  }
}

// ====== ÏÑºÏÑú ÎÖ∏Îìú Ï¥àÍ∏∞Ìôî ======
void initializeSensors() {
  sensors[0].name = "SensorNode_1";
  sensors[1].name = "SensorNode_2";
  
  for (int i = 0; i < NUM_SENSORS; i++) {
    sensors[i].pClient = nullptr;
    sensors[i].pRemoteCharacteristic = nullptr;
    sensors[i].device = nullptr;
    sensors[i].connected = false;
    sensors[i].doConnect = false;
    sensors[i].dataBuffer = "";
    sensors[i].lastDataTime = 0;
    sensors[i].lastConnectionAttempt = 0;
    sensors[i].openBraces = 0;
    sensors[i].closeBraces = 0;
    sensors[i].inString = false;
    sensors[i].escapeNext = false;
  }
}

// ====== JSON ÏôÑÏÑ±ÎèÑ Ï≤¥ÌÅ¨ Ìï®Ïàò ======
bool isCompleteJson(const String& jsonData, int sensorIndex) {
  SensorNode& sensor = sensors[sensorIndex];
  
  for (int i = 0; i < jsonData.length(); i++) {
    char c = jsonData.charAt(i);
    
    if (sensor.escapeNext) {
      sensor.escapeNext = false;
      continue;
    }
    
    if (c == '\\' && sensor.inString) {
      sensor.escapeNext = true;
      continue;
    }
    
    if (c == '"' && !sensor.escapeNext) {
      sensor.inString = !sensor.inString;
      continue;
    }
    
    if (!sensor.inString) {
      if (c == '{') {
        sensor.openBraces++;
      } else if (c == '}') {
        sensor.closeBraces++;
      }
    }
  }
  
  // JSONÏù¥ ÏôÑÏÑ±ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
  return (sensor.openBraces > 0 && sensor.openBraces == sensor.closeBraces);
}

// ====== Î≤ÑÌçº Î¶¨ÏÖã Ìï®Ïàò ======
void resetSensorBuffer(int sensorIndex) {
  sensors[sensorIndex].dataBuffer = "";
  sensors[sensorIndex].openBraces = 0;
  sensors[sensorIndex].closeBraces = 0;
  sensors[sensorIndex].inString = false;
  sensors[sensorIndex].escapeNext = false;
}

// ====== JSON Ï≤òÎ¶¨ Ìï®Ïàò ======
void processCompleteJson(String jsonData, int sensorIndex) {
  MySerial.println("üì® [" + sensors[sensorIndex].name + "] ÏôÑÏ†ÑÌïú JSON Îç∞Ïù¥ÌÑ∞: " + jsonData);

  // JSON ÌååÏã±
  JsonDocument doc;
  DeserializationError error = deserializeJson(doc, jsonData);

  if (error) {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] JSON ÌååÏã± Ïò§Î•ò: " + String(error.c_str()));
    return;
  }

  // Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú Î∞è Ï≤òÎ¶¨
  String macAddress = doc["mac"].as<String>();

  if (doc["error"].is<String>()) {
    String errorMsg = doc["error"];
    MySerial.println("‚ö†Ô∏è [" + sensors[sensorIndex].name + "] ÏÑºÏÑú Ïò§Î•ò - MAC: " + macAddress + ", Ïò§Î•ò: " + errorMsg);
  } else if (doc["temp"].is<float>()) {
    float temperature = doc["temp"];
    MySerial.printf("üå°Ô∏è [%s] Ïò®ÎèÑ Îç∞Ïù¥ÌÑ∞ - MAC: %s, Ïò®ÎèÑ: %.2f¬∞C\n", 
                    sensors[sensorIndex].name.c_str(), macAddress.c_str(), temperature);

    // Ïò®ÎèÑ ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
    if (temperature > 30.0) {
      MySerial.println("üî• [" + sensors[sensorIndex].name + "] Í≥†Ïò® Í≤ΩÍ≥†! Ïò®ÎèÑÍ∞Ä 30¬∞CÎ•º Ï¥àÍ≥ºÌñàÏäµÎãàÎã§.");
    }
  }
  
  // MQTTÎ°ú Îç∞Ïù¥ÌÑ∞ Î∞úÌñâ
  publishSensorData(sensors[sensorIndex].name, jsonData);
}

// ====== ÏïåÎ¶º ÏΩúÎ∞± Ìï®Ïàò (ÏÑºÏÑúÎ≥Ñ) ======
class SensorNotifyCallback : public BLEClientCallbacks {
private:
  int sensorIndex;

public:
  SensorNotifyCallback(int index) : sensorIndex(index) {}

  void onConnect(BLEClient* pclient) override {
    MySerial.println("‚úÖ [" + sensors[sensorIndex].name + "] BLE ÏÑúÎ≤ÑÏóê Ïó∞Í≤∞Îê®!");
    
    // MTU ÌÅ¨Í∏∞ ÌòëÏÉÅ ÏãúÎèÑ (Ï∂îÍ∞Ä)
    if (pclient->setMTU(517)) {  // ÏµúÎåÄ MTU ÌÅ¨Í∏∞ ÏÑ§Ï†ï ÏãúÎèÑ
      MySerial.println("üìè [" + sensors[sensorIndex].name + "] MTU ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä ÏãúÎèÑ ÏôÑÎ£å");
    }
    
    sensors[sensorIndex].connected = true;
    
    // MQTTÎ°ú Ïó∞Í≤∞ ÏÉÅÌÉú Î∞úÌñâ
    if (mqttClient.connected()) {
      String topic = mqttTopicPrefix + sensors[sensorIndex].name + "/status";
      mqttClient.publish(topic.c_str(), "connected", true);
    }
  }

  void onDisconnect(BLEClient* pclient) override {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] BLE ÏÑúÎ≤ÑÏóêÏÑú Ïó∞Í≤∞ Ìï¥Ï†úÎê®");
    sensors[sensorIndex].connected = false;
    resetSensorBuffer(sensorIndex);
    doScan = true;  // Ïû¨Ïä§Ï∫î ÏãúÏûë
    
    // MQTTÎ°ú Ïó∞Í≤∞ Ìï¥Ï†ú ÏÉÅÌÉú Î∞úÌñâ
    if (mqttClient.connected()) {
      String topic = mqttTopicPrefix + sensors[sensorIndex].name + "/status";
      mqttClient.publish(topic.c_str(), "disconnected", true);
    }
  }
};


// ====== Í≥µÌÜµ ÏïåÎ¶º Ï≤òÎ¶¨ Ìï®Ïàò Ï∂îÍ∞Ä ======
void processNotification(int sensorIndex, uint8_t* pData, size_t length) {
  String receivedChunk = String((char*)pData, length);
  MySerial.println("üì§ [" + sensors[sensorIndex].name + "] ÏàòÏã†Îêú Ï≤≠ÌÅ¨ (" + String(length) + " bytes): " + receivedChunk);
  
  sensors[sensorIndex].dataBuffer += receivedChunk;
  sensors[sensorIndex].lastDataTime = millis();
  
  // JSON ÏôÑÏÑ±ÎèÑ Ï≤¥ÌÅ¨ (Í∏∞Ï°¥Ïùò Îã®ÏàúÌïú endsWith("}") ÎåÄÏã† Ï†ïÍµêÌïú ÌååÏã±)
  if (isCompleteJson(sensors[sensorIndex].dataBuffer, sensorIndex)) {
    processCompleteJson(sensors[sensorIndex].dataBuffer, sensorIndex);
    resetSensorBuffer(sensorIndex);  // Í∏∞Ï°¥Ïùò Îã®Ïàú Ï¥àÍ∏∞Ìôî ÎåÄÏã† Ï†ÑÏö© Ìï®Ïàò ÏÇ¨Ïö©
  }
  
  // Î≤ÑÌçº ÌÅ¨Í∏∞ Ï†úÌïú (Î©îÎ™®Î¶¨ Î≥¥Ìò∏) - ÏÉàÎ°ú Ï∂îÍ∞Ä
  if (sensors[sensorIndex].dataBuffer.length() > 1000) {
    MySerial.println("‚ö†Ô∏è [" + sensors[sensorIndex].name + "] Î≤ÑÌçº ÌÅ¨Í∏∞ Ï¥àÍ≥º, Ï¥àÍ∏∞Ìôî");
    resetSensorBuffer(sensorIndex);
  }
}

void notifyCallback1(BLERemoteCharacteristic* pBLERemoteCharacteristic, uint8_t* pData, size_t length, bool isNotify) {
  processNotification(0, pData, length);  // Í≥µÌÜµ Ìï®ÏàòÎ°ú Í∞ÑÏÜåÌôî
}

void notifyCallback2(BLERemoteCharacteristic* pBLERemoteCharacteristic, uint8_t* pData, size_t length, bool isNotify) {
  processNotification(1, pData, length);  // Í≥µÌÜµ Ìï®ÏàòÎ°ú Í∞ÑÏÜåÌôî
}

// ====== Ïû•Ïπò Ïä§Ï∫î ÏΩúÎ∞± ======
class MyAdvertisedDeviceCallbacks : public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) override {
    MySerial.printf("üì° BLE Ïû•Ïπò Î∞úÍ≤¨: %s\n", advertisedDevice.toString().c_str());

    // Í∞Å ÏÑºÏÑú ÎÖ∏Îìú ÌôïÏù∏
    if (advertisedDevice.haveName()) {
      String deviceName = String(advertisedDevice.getName().c_str());
      for (int i = 0; i < NUM_SENSORS; i++) {
        if (deviceName == sensors[i].name && 
            !sensors[i].connected && 
            sensors[i].device == nullptr) {
          
          MySerial.println("üéØ ÌÉÄÍ≤ü Ïû•Ïπò Î∞úÍ≤¨: " + sensors[i].name);
          sensors[i].device = new BLEAdvertisedDevice(advertisedDevice);
          sensors[i].doConnect = true;
          break;
        }
      }
    }
  }
};

// ====== ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ìï®Ïàò ======
bool connectToServer(int sensorIndex) {
  MySerial.printf("üîó [%s] ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏãúÎèÑ: %s\n", 
                  sensors[sensorIndex].name.c_str(), 
                  sensors[sensorIndex].device->getAddress().toString().c_str());

  sensors[sensorIndex].pClient = BLEDevice::createClient();
  sensors[sensorIndex].pClient->setClientCallbacks(new SensorNotifyCallback(sensorIndex));

  // ÏÑúÎ≤Ñ Ïó∞Í≤∞
  if (!sensors[sensorIndex].pClient->connect(sensors[sensorIndex].device)) {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®");
    return false;
  }

  MySerial.println("‚úÖ [" + sensors[sensorIndex].name + "] ÏÑúÎ≤Ñ Ïó∞Í≤∞ ÏÑ±Í≥µ");

  // ÏÑúÎπÑÏä§ Ï∞∏Ï°∞ ÌöçÎìù
  BLERemoteService* pRemoteService = sensors[sensorIndex].pClient->getService(SERVICE_UUID);
  if (pRemoteService == nullptr) {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] ÏÑúÎπÑÏä§Î•º Ï∞æÏùÑ Ïàò ÏóÜÏùå");
    sensors[sensorIndex].pClient->disconnect();
    return false;
  }

  MySerial.println("‚úÖ [" + sensors[sensorIndex].name + "] ÏÑúÎπÑÏä§ Î∞úÍ≤¨Îê®");

  // ÌäπÏÑ± Ï∞∏Ï°∞ ÌöçÎìù
  sensors[sensorIndex].pRemoteCharacteristic = pRemoteService->getCharacteristic(CHARACTERISTIC_UUID);
  if (sensors[sensorIndex].pRemoteCharacteristic == nullptr) {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] ÌäπÏÑ±ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏùå");
    sensors[sensorIndex].pClient->disconnect();
    return false;
  }

  MySerial.println("‚úÖ [" + sensors[sensorIndex].name + "] ÌäπÏÑ± Î∞úÍ≤¨Îê®");

  // ÏïåÎ¶º Îì±Î°ù (ÏÑºÏÑúÎ≥Ñ ÏΩúÎ∞± Ìï®Ïàò ÏÇ¨Ïö©)
  if (sensors[sensorIndex].pRemoteCharacteristic->canNotify()) {
    if (sensorIndex == 0) {
      sensors[sensorIndex].pRemoteCharacteristic->registerForNotify(notifyCallback1);
    } else {
      sensors[sensorIndex].pRemoteCharacteristic->registerForNotify(notifyCallback2);
    }
    MySerial.println("‚úÖ [" + sensors[sensorIndex].name + "] ÏïåÎ¶º Îì±Î°ù ÏôÑÎ£å");
  } else {
    MySerial.println("‚ùå [" + sensors[sensorIndex].name + "] ÏïåÎ¶º Í∏∞Îä• ÏßÄÏõê ÏïàÎê®");
  }

  return true;
}

// ====== Ïä§Ï∫î ÏãúÏûë Ìï®Ïàò ======
void startScan() {
  MySerial.println("üîç BLE Ïû•Ïπò Ïä§Ï∫î ÏãúÏûë...");
  pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  pBLEScan->setInterval(1349);
  pBLEScan->setWindow(449);
  pBLEScan->setActiveScan(true);
  pBLEScan->start(5, false);  // 5Ï¥à ÎèôÏïà Ïä§Ï∫î
}

// ====== Ïó∞Í≤∞ ÏÉÅÌÉú Ï∂úÎ†• ======
void printConnectionStatus() {
  static unsigned long lastStatusPrint = 0;
  unsigned long currentTime = millis();
  
  if (currentTime - lastStatusPrint >= 15000) {  // 15Ï¥àÎßàÎã§ ÏÉÅÌÉú Ï∂úÎ†•
    MySerial.println("\n=== Ïó∞Í≤∞ ÏÉÅÌÉú ===");
    MySerial.println("WiFi: " + String(WiFi.status() == WL_CONNECTED ? "Ïó∞Í≤∞Îê®" : "Ïó∞Í≤∞ ÏïàÎê®"));
    MySerial.println("MQTT: " + String(mqttClient.connected() ? "Ïó∞Í≤∞Îê®" : "Ïó∞Í≤∞ ÏïàÎê®"));
    
    for (int i = 0; i < NUM_SENSORS; i++) {
      String status = sensors[i].connected ? "Ïó∞Í≤∞Îê®" : "Ïó∞Í≤∞ ÏïàÎê®";
      String bufferInfo = sensors[i].dataBuffer.length() > 0 ? 
                         " (Î≤ÑÌçº: " + String(sensors[i].dataBuffer.length()) + " bytes)" : "";  // Ï∂îÍ∞Ä
      MySerial.println(sensors[i].name + ": " + status + bufferInfo);  // Î≥ÄÍ≤Ω
    }
    MySerial.println("================\n");
    lastStatusPrint = currentTime;
  }
}

void setup() {
  // UART1 ÏãúÏûë
  MySerial.begin(115200, SERIAL_8N1, UART_RX, UART_TX);
  delay(1000);
  MySerial.println("=== BLE Îã§Ï§ë ÏÑºÏÑú ÏàòÏã†Í∏∞ + MQTT Í≤åÏù¥Ìä∏Ïõ®Ïù¥ ÏãúÏûë ===");
  MySerial.println("‚úÖ UART1 ÏãúÏûëÎê®");

  // WiFi Ïó∞Í≤∞
  connectToWiFi();
  
  // MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÏÑ§Ï†ï
  mqttClient.setServer(mqttServerAddress, mqttPort);
  mqttClient.setKeepAlive(60);      // Keep-alive 60Ï¥à
  mqttClient.setSocketTimeout(30);  // ÏÜåÏºì ÌÉÄÏûÑÏïÑÏõÉ 30Ï¥à
  
  MySerial.println("üîí MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î≥¥Ïïà ÏÑ§Ï†ï ÏôÑÎ£å");
  
  // ÏÑºÏÑú ÎÖ∏Îìú Ï¥àÍ∏∞Ìôî
  initializeSensors();
  
  // BLE Ï¥àÍ∏∞Ìôî
  BLEDevice::init("BLE_MultiReceiver");
  BLEDevice::setMTU(517);
  MySerial.println("üìè MTU ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä ÏãúÎèÑ ÏôÑÎ£å");

  MySerial.println("‚úÖ BLE Ï¥àÍ∏∞Ìôî ÏôÑÎ£å");

  // Ïä§Ï∫î ÏãúÏûë
  doScan = true;
  MySerial.println("üîç ÌÉÄÍ≤ü Ïû•Ïπò Í≤ÄÏÉâ Ï§ë: SensorNode_1, SensorNode_2");
}

void loop() {
  // WiFi Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
  if (WiFi.status() != WL_CONNECTED) {
    MySerial.println("‚ö†Ô∏è WiFi Ïó∞Í≤∞ ÎÅäÏñ¥Ïßê, Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ...");
    connectToWiFi();
  }
  
  // MQTT Ïó∞Í≤∞ ÌôïÏù∏ Î∞è Ïû¨Ïó∞Í≤∞
  if (WiFi.status() == WL_CONNECTED && !mqttClient.connected()) {
    unsigned long currentTime = millis();
    if (currentTime - lastMqttReconnectAttempt >= MQTT_RECONNECT_INTERVAL) {
      connectToMQTT();
      lastMqttReconnectAttempt = currentTime;
    }
  }
  
  // MQTT ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Î£®ÌîÑ Ï≤òÎ¶¨
  if (mqttClient.connected()) {
    mqttClient.loop();
  }

  // Í∞Å ÏÑºÏÑú ÎÖ∏Îìú Ïó∞Í≤∞ ÏãúÎèÑ
  for (int i = 0; i < NUM_SENSORS; i++) {
    if (sensors[i].doConnect && !sensors[i].connected) {
      if (connectToServer(i)) {
        MySerial.println("üéâ [" + sensors[i].name + "] Ïó∞Í≤∞ Î∞è ÏÑ§Ï†ï ÏôÑÎ£å!");
      } else {
        MySerial.println("‚ùå [" + sensors[i].name + "] Ïó∞Í≤∞ Ïã§Ìå®, Ïû¨ÏãúÎèÑ ÏòàÏ†ï");
        sensors[i].lastConnectionAttempt = millis();
      }
      sensors[i].doConnect = false;
    }
  }

  // Ïä§Ï∫î ÏãúÏûë
  if (doScan) {
    // Î™®Îì† ÏÑºÏÑúÍ∞Ä Ïó∞Í≤∞ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
    bool allConnected = true;
    for (int i = 0; i < NUM_SENSORS; i++) {
      if (!sensors[i].connected) {
        allConnected = false;
        break;
      }
    }
    
    if (!allConnected) {
      unsigned long currentTime = millis();
      if (currentTime - lastScanTime >= SCAN_INTERVAL) {
        startScan();
        lastScanTime = currentTime;
      }
    } else {
      doScan = false;  // Î™®Îì† ÏÑºÏÑúÍ∞Ä Ïó∞Í≤∞ÎêòÎ©¥ Ïä§Ï∫î Ï§ëÏßÄ
    }
  }

  // Ïó∞Í≤∞ Ïã§Ìå® ÌõÑ Ïû¨ÏãúÎèÑ
  for (int i = 0; i < NUM_SENSORS; i++) {
    if (!sensors[i].connected && sensors[i].device != nullptr) {
      unsigned long currentTime = millis();
      if (currentTime - sensors[i].lastConnectionAttempt >= CONNECTION_RETRY_INTERVAL) {
        MySerial.println("üîÑ [" + sensors[i].name + "] Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ...");
        sensors[i].doConnect = true;
        sensors[i].lastConnectionAttempt = currentTime;
      }
    }
  }

  // Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
  for (int i = 0; i < NUM_SENSORS; i++) {
    if (sensors[i].connected && sensors[i].pClient != nullptr && !sensors[i].pClient->isConnected()) {
      MySerial.println("‚ö†Ô∏è [" + sensors[i].name + "] Ïó∞Í≤∞ ÏÉÅÌÉú Î∂àÏùºÏπò Í∞êÏßÄ, Ïû¨ÏÑ§Ï†ï");
      sensors[i].connected = false;
      doScan = true;
    }
  }

// Î≤ÑÌçº ÌÉÄÏûÑÏïÑÏõÉ Ï≤òÎ¶¨
for (int i = 0; i < NUM_SENSORS; i++) {
  if (sensors[i].dataBuffer.length() > 0) {
    unsigned long currentTime = millis();
    if (currentTime - sensors[i].lastDataTime >= DATA_TIMEOUT) {
      MySerial.println("‚è∞ [" + sensors[i].name + "] Îç∞Ïù¥ÌÑ∞ ÏàòÏã† ÌÉÄÏûÑÏïÑÏõÉ, Î≤ÑÌçº Ï¥àÍ∏∞Ìôî");
      MySerial.println("üóëÔ∏è [" + sensors[i].name + "] Î≤ÑÎ†§ÏßÑ Îç∞Ïù¥ÌÑ∞: " + sensors[i].dataBuffer);
      resetSensorBuffer(i);  // Î≥ÄÍ≤Ω: Îã®Ïàú Ï¥àÍ∏∞Ìôî ÎåÄÏã† Ï†ÑÏö© Ìï®Ïàò ÏÇ¨Ïö©
    }
  }
}

  // Ïó∞Í≤∞ ÏÉÅÌÉú Ï∂úÎ†•
  printConnectionStatus();
  
  delay(100);  // 100ms ÎåÄÍ∏∞
}